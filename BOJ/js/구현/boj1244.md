# boj1244 스위치 켜고 끄기

**알게 된 점**

### 남학생 로직

- 전구의 개수 / 남학생 숫자 반내림을 이용해 mult \* num으로 list 접근했는데, 굳이 mult \* num을 할 필요가 없다.

```js
for (let j = num; j <= n; j += num) {
  arr[j - 1] = arr[j - 1] === 1 ? 0 : 1;
}
```

```js
for (let i = 1; i * boysNumber <= sw; i++) {
  status[i * boysNumber - 1] = status[i * boysNumber - 1] === 1 ? 0 : 1;
}
```

### 여학생 로직

- while문을 이용해, 대칭을 이루지 않거나 혹은 0 <= left || rigth >= end 일 경우 break를 해 left ~ rigth 범위를 한번에 다 바꾸려고 했다. 하지만 받은 숫자만 바꿔야하는 케이스가 있음을 고려하지 못했다.
  -> 점점 복잡해졌다.

```

* 처음에 짰던 여학생 로직
* - 너무 복잡하고 분기처리할 것이 많다.
* -> 1. num === start || num === end라면 list[num]만 바꿔야한다.
* -> 2.1번 상황을 따로 분기처리했다면
* 대칭의 값이 안 맞을때, 혹은 left right가 범위를 넘어갔을때 한꺼번에 바꾸는 로직은 list[num]을 제외해야한다.
  -> 너무 복잡하다.

```

- 다음부터는 하나씩 바꾸는 로직을 로직을 사용하도록 하자.

```js
let index = num - 1;
arr[index] = arr[index] === 1 ? 0 : 1;
for (let j = 1; index - j >= 0 && index + j < n; ++j) {
  if (arr[index - j] == arr[index + j]) {
    arr[index - j] = arr[index - j] === 1 ? 0 : 1;
    arr[index + j] = arr[index + j] === 1 ? 0 : 1;
  } else {
    break;
  }
}
```

- for문안의 조건문을 이용해left right 가 인덱스 범위를 벗어나는 것을 막을 수 있다.
- 가독성이 훨씬 좋다.

```js
const changeStatusByGirls = (girlsNumber) => {
  status[girlsNumber - 1] = status[girlsNumber - 1] === 1 ? 0 : 1;
  let leftPointer = girlsNumber - 2;
  let rightPointer = girlsNumber;
  while (leftPointer >= 0 && rightPointer < sw) {
    if (status[leftPointer] !== status[rightPointer]) break;

    //어차피 두 개의 값은 같기 때문에 이렇게 해도 된다.
    status[leftPointer] = status[rightPointer] =
      status[leftPointer] === 1 ? 0 : 1;

    leftPointer--;
    rightPointer++;
  }
};
```

- 조건문이 한번만 계산되기 때문에 좀 더 빠를 수 있다.
